<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#3367D6"/>
  <link rel="apple-touch-icon" href="/icons-192.png">
  <link rel="manifest" href="/manifest.json">
  
  <meta name="generator" content="Hexo 7.3.0">

  

  

  
    <meta name="author" content="长情">
  

  

  

  <title>负载均衡算法 | 长情</title>

  

  
    <link rel="shortcut icon" href="/favicon.ico">
  

  

  

  

  
<link rel="stylesheet" href="/css/style.css">

</head>
<body>
  <div class="root-container">
    
<!-- header container -->
<header class="header-container post">
  
    <div class="post-image" style="background-image: url(/1704264337798170426433788.jpg)"></div>
  

  <!-- navbar -->
<nav class="navbar">
  <div class="navbar-content">
    <!-- logo -->
    <div class="navbar-logo">
      <a href="/">
        
          长情
        
      </a>
    </div>
    <!-- link -->
    <div class="navbar-link">
      <div class="navbar-btn">
        <div></div>
        <div></div>
        <div></div>
      </div>
      <ul class="navbar-list">
        
          <li class="navbar-list-item"><a href="/">首页</a></li>
        
          <li class="navbar-list-item"><a href="/archives">归档</a></li>
        
          <li class="navbar-list-item"><a href="/links">友链</a></li>
        
          <li class="navbar-list-item"><a href="/about">关于</a></li>
        
      </ul>
    </div>
  </div>
</nav>

  
  

  
  

  
  

  
  

  
  
    <div class="header-content">
      <div class="post-text layout-block">
        <div class="layout-margin">
          <h1 class="title-wrap">负载均衡算法</h1>
          <h2 class="title-sub-wrap">
            <strong>长情</strong>
            <span>发布于</span>
            <time  class="article-date" datetime="2024-04-05T16:19:48.000Z" itemprop="datePublished">2024-04-06</time>
          </h2>
          
            <h2 class="last-time">
              <span>最后更新于</span>
              <time  class="article-updated" datetime="2025-04-05T16:20:49.388Z" itemprop="dateUpdated">2025-04-06</time>
            </h2>
          
          
          <ul class="wrap-list dark">
  
</ul>
          <ul class="wrap-list dark">
  
</ul>
        </div>
      </div>
    </div>
  

  
  
  
</header>

    <!-- 文章 -->

<!-- 文章内容 -->
<div class="body-container">
  <article class="content-container layout-block post-container">
    <div class="article-info">
      
      
      
      
      <section class="article-entry markdown-body layout-margin content-padding--large soft-size--large soft-style--box">
        <table>
<thead>
<tr>
<th>算法</th>
<th>适用场景</th>
<th>优势</th>
<th>劣势</th>
</tr>
</thead>
<tbody><tr>
<td>轮询</td>
<td>服务器性能相近</td>
<td>简单易实现</td>
<td>无法考虑实际负载</td>
</tr>
<tr>
<td>加权轮询</td>
<td>服务器性能不同</td>
<td>可调节负载</td>
<td>需要手动设定权重</td>
</tr>
<tr>
<td>最小连接</td>
<td>长连接应用</td>
<td>适应流量动态变化</td>
<td>需要跟踪连接数</td>
</tr>
<tr>
<td>加权最小连接</td>
<td>服务器性能不同的长连接应用</td>
<td>负载更均衡</td>
<td>计算复杂度更高</td>
</tr>
<tr>
<td>IP 哈希</td>
<td>会话保持</td>
<td>客户端始终访问同一服务器</td>
<td>负载可能不均衡</td>
</tr>
<tr>
<td>一致性哈希</td>
<td>分布式缓存</td>
<td>服务器扩展性好</td>
<td>计算成本较高</td>
</tr>
<tr>
<td>最短响应时间</td>
<td>需要动态调整</td>
<td>分配更合理</td>
<td>需要额外监控</td>
</tr>
<tr>
<td>随机</td>
<td>小规模集群</td>
<td>负载均衡简单</td>
<td>可能导致负载不均</td>
</tr>
<tr>
<td>负载感知</td>
<td>负载波动大的系统</td>
<td>适应性强</td>
<td>实现复杂</td>
</tr>
<tr>
<td>动态反馈</td>
<td>云计算环境</td>
<td>高度智能</td>
<td>计算开销高</td>
</tr>
</tbody></table>
<h1 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a><strong>轮询</strong></h1><h4 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a><strong>1. 原理</strong></h4><p>轮询（Round Robin）是一种最简单的负载均衡算法，它会将请求依次分配给集群中的服务器，循环进行。例如，如果有 3 台服务器，第一请求会分配给服务器 A，第二个请求分配给服务器 B，第三个请求分配给服务器 C，然后第四个请求又返回到服务器 A，依此类推。</p>
<h4 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2. 适用场景"></a><strong>2. 适用场景</strong></h4><ul>
<li><strong>服务器性能基本相同</strong></li>
<li><strong>请求处理时间较短且均匀</strong></li>
<li><strong>不需要考虑服务器的当前负载</strong></li>
<li><strong>适用于 HTTP 负载均衡（如 Nginx、HAProxy）</strong></li>
</ul>
<h4 id="3-优势"><a href="#3-优势" class="headerlink" title="3. 优势"></a><strong>3. 优势</strong></h4><p>✅ <strong>实现简单</strong>：无需复杂计算，直接轮流分配请求。<br>✅ <strong>请求均匀分布</strong>：在理想情况下，每台服务器都会接收到相同数量的请求。<br>✅ <strong>易于扩展</strong>：增加或减少服务器不会影响调度逻辑。</p>
<h4 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4. 缺点"></a><strong>4. 缺点</strong></h4><p>❌ <strong>不能感知服务器负载</strong>：如果某台服务器处理速度较慢，它可能会积压请求，而其他服务器可能仍然空闲。<br>❌ <strong>不适用于长连接</strong>：如果某些请求的处理时间较长，会导致负载不均衡。<br>❌ <strong>忽略服务器性能差异</strong>：所有服务器都会被分配相同的请求量，即使它们的计算能力不同。</p>
<h4 id="5-变种"><a href="#5-变种" class="headerlink" title="5. 变种"></a><strong>5. 变种</strong></h4><ol>
<li><strong>加权轮询（Weighted Round Robin）</strong><ul>
<li>为每台服务器设置不同的权重，性能高的服务器接收更多请求。</li>
</ul>
</li>
<li><strong>动态轮询（Dynamic Round Robin）</strong><ul>
<li>根据服务器的实时负载情况动态调整分配策略。</li>
</ul>
</li>
</ol>
<h4 id="6-示例"><a href="#6-示例" class="headerlink" title="6. 示例"></a><strong>6. 示例</strong></h4><p>假设有 3 台服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">服务器 A</span><br><span class="line">服务器 B</span><br><span class="line">服务器 C</span><br></pre></td></tr></table></figure>

<p>请求的分配顺序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">请求 1 -&gt; A</span><br><span class="line">请求 2 -&gt; B</span><br><span class="line">请求 3 -&gt; C</span><br><span class="line">请求 4 -&gt; A</span><br><span class="line">请求 5 -&gt; B</span><br><span class="line">请求 6 -&gt; C</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这个过程会一直循环，保证每台服务器都能接收到均衡的请求数量。</p>
<h4 id="7-适用的负载均衡器"><a href="#7-适用的负载均衡器" class="headerlink" title="7. 适用的负载均衡器"></a><strong>7. 适用的负载均衡器</strong></h4><ul>
<li><strong>Nginx</strong></li>
<li><strong>HAProxy</strong></li>
<li><strong>Apache HTTP Server</strong></li>
<li><strong>F5 BIG-IP</strong></li>
<li><strong>Kubernetes Service（默认调度策略）</strong></li>
</ul>
<hr>
<p><strong>总结</strong>：轮询是一种简单高效的负载均衡算法，适用于请求处理时间均匀、服务器性能相似的场景。但在复杂业务环境下，可能需要加权轮询或其他更智能的策略来优化负载均衡。</p>
<h1 id="加权轮询"><a href="#加权轮询" class="headerlink" title="加权轮询"></a><strong>加权轮询</strong></h1><h4 id="1-原理-1"><a href="#1-原理-1" class="headerlink" title="1. 原理"></a><strong>1. 原理</strong></h4><p>加权轮询（Weighted Round Robin, WRR）是在轮询（Round Robin）的基础上，为每台服务器分配一个<strong>权重（Weight）</strong>，权重越高的服务器会分配到更多的请求。例如：</p>
<ul>
<li>服务器 A（权重 3）</li>
<li>服务器 B（权重 2）</li>
<li>服务器 C（权重 1）</li>
</ul>
<p>请求的分配顺序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; A -&gt; A -&gt; B -&gt; B -&gt; C -&gt; A -&gt; A -&gt; A -&gt; B -&gt; B -&gt; C -&gt; ...</span><br></pre></td></tr></table></figure>

<p>这样，性能较强的服务器会处理更多的请求，保证了负载均衡的合理性。</p>
<hr>
<h4 id="2-适用场景-1"><a href="#2-适用场景-1" class="headerlink" title="2. 适用场景"></a><strong>2. 适用场景</strong></h4><p>✅ <strong>服务器性能不同</strong>（如 CPU、内存、带宽等配置不同）<br>✅ <strong>请求处理时间不同</strong>（部分请求可能较重）<br>✅ <strong>需要更精细的负载控制</strong>  </p>
<hr>
<h4 id="3-优势-1"><a href="#3-优势-1" class="headerlink" title="3. 优势"></a><strong>3. 优势</strong></h4><p>✅ <strong>考虑服务器性能</strong>，高性能服务器承担更多请求，提高资源利用率。<br>✅ <strong>更均衡的流量分配</strong>，避免低性能服务器被过载。<br>✅ <strong>易扩展</strong>，可以动态调整权重以优化负载分配。  </p>
<hr>
<h4 id="4-缺点-1"><a href="#4-缺点-1" class="headerlink" title="4. 缺点"></a><strong>4. 缺点</strong></h4><p>❌ <strong>权重需要手动设置</strong>，如果权重不合理，可能导致负载不均衡。<br>❌ <strong>无法动态感知服务器负载</strong>，不会实时调整权重（可结合<strong>动态加权</strong>算法优化）。  </p>
<hr>
<h4 id="5-变种-1"><a href="#5-变种-1" class="headerlink" title="5. 变种"></a><strong>5. 变种</strong></h4><ol>
<li><strong>动态加权轮询（Dynamic Weighted Round Robin, DWRR）</strong>  <ul>
<li>监测服务器的实时负载（如 CPU、内存、响应时间）动态调整权重。</li>
</ul>
</li>
<li><strong>平滑加权轮询（Smooth Weighted Round Robin, SWRR）</strong>  <ul>
<li>避免某些请求连续落在同一台服务器，分配更加平滑。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="6-示例-1"><a href="#6-示例-1" class="headerlink" title="6. 示例"></a><strong>6. 示例</strong></h4><h5 id="1-服务器及权重"><a href="#1-服务器及权重" class="headerlink" title="(1) 服务器及权重"></a><strong>(1) 服务器及权重</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">服务器 A (Weight = 5)</span><br><span class="line">服务器 B (Weight = 3)</span><br><span class="line">服务器 C (Weight = 2)</span><br></pre></td></tr></table></figure>

<h5 id="2-请求分配"><a href="#2-请求分配" class="headerlink" title="(2) 请求分配"></a><strong>(2) 请求分配</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; A -&gt; A -&gt; A -&gt; A -&gt; B -&gt; B -&gt; B -&gt; C -&gt; C</span><br><span class="line">A -&gt; A -&gt; A -&gt; A -&gt; A -&gt; B -&gt; B -&gt; B -&gt; C -&gt; C</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>服务器 A 处理 50% 的请求，B 处理 30%，C 处理 20%。</p>
<hr>
<h4 id="7-适用的负载均衡器-1"><a href="#7-适用的负载均衡器-1" class="headerlink" title="7. 适用的负载均衡器"></a><strong>7. 适用的负载均衡器</strong></h4><ul>
<li><strong>Nginx</strong>（支持 <code>weight</code> 参数）</li>
<li><strong>HAProxy</strong></li>
<li><strong>Apache HTTP Server</strong></li>
<li><strong>Kubernetes Ingress</strong></li>
<li><strong>F5 BIG-IP</strong></li>
</ul>
<hr>
<p>加权轮询（WRR）适用于<strong>服务器性能不同</strong>的场景，可以让高性能服务器承担更多请求。然而，它不能动态感知服务器负载，适合负载比较稳定的环境。如果需要更智能的调度，可以结合<strong>动态加权轮询</strong>或<strong>最小连接数</strong>策略。</p>
<h1 id="最小连接数"><a href="#最小连接数" class="headerlink" title="最小连接数"></a><strong>最小连接数</strong></h1><h2 id="1-原理-2"><a href="#1-原理-2" class="headerlink" title="1. 原理"></a><strong>1. 原理</strong></h2><p>最小连接数（Least Connections, LC）是一种动态负载均衡算法，它会<strong>将新的请求分配给当前活跃连接数最少的服务器</strong>。相比于轮询（Round Robin）算法，它考虑了每台服务器的<strong>实时负载</strong>，适用于处理时间较长的请求（如数据库查询、WebSocket 连接等）。</p>
<p><strong>工作流程：</strong></p>
<ol>
<li>负载均衡器跟踪每台服务器的当前活跃连接数。</li>
<li>每当有新的请求时，将其分配给连接数最少的服务器，以尽可能均衡负载。</li>
<li>服务器处理完请求后，连接数减少，等待新的分配。</li>
</ol>
<hr>
<h2 id="2-适用场景-2"><a href="#2-适用场景-2" class="headerlink" title="2. 适用场景"></a><strong>2. 适用场景</strong></h2><p>✅ <strong>请求处理时间不均匀</strong>（如长连接、数据库查询等）<br>✅ <strong>服务器性能相近，但负载不均</strong><br>✅ <strong>高并发应用（如 API 网关、反向代理、WebSocket 服务器）</strong></p>
<hr>
<h2 id="3-优势-2"><a href="#3-优势-2" class="headerlink" title="3. 优势"></a><strong>3. 优势</strong></h2><p>✅ <strong>更智能的分配策略</strong>，可以避免某些服务器过载。<br>✅ <strong>适用于长连接</strong>，比如数据库连接池、WebSocket、视频流等。<br>✅ <strong>更均衡的负载分配</strong>，相比轮询更合理。</p>
<hr>
<h2 id="4-缺点-2"><a href="#4-缺点-2" class="headerlink" title="4. 缺点"></a><strong>4. 缺点</strong></h2><p>❌ <strong>需要实时监测服务器的连接数</strong>，比轮询算法更复杂。<br>❌ <strong>无法考虑服务器性能差异</strong>，所有服务器默认处理能力相同。<br>❌ <strong>连接数少 ≠ 负载低</strong>，某些请求可能占用大量 CPU 或内存。</p>
<hr>
<h2 id="5-变种-2"><a href="#5-变种-2" class="headerlink" title="5. 变种"></a><strong>5. 变种</strong></h2><ol>
<li><strong>加权最小连接数（Weighted Least Connections, WLC）</strong><ul>
<li>结合服务器权重，性能更高的服务器分配更多请求。</li>
</ul>
</li>
<li><strong>最小连接数 + 服务器响应时间（Least Response Time, LRT）</strong><ul>
<li>结合服务器的<strong>响应时间</strong>，分配请求给<strong>连接数少 + 处理快</strong>的服务器。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="6-示例-2"><a href="#6-示例-2" class="headerlink" title="6. 示例"></a><strong>6. 示例</strong></h2><p>假设有 3 台服务器，它们的活跃连接数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">服务器 A: 10 连接</span><br><span class="line">服务器 B: 5 连接</span><br><span class="line">服务器 C: 7 连接</span><br></pre></td></tr></table></figure>

<p>新请求会被分配给 <strong>服务器 B</strong>，因为它的活跃连接数最少（5 连接）。</p>
<hr>
<h2 id="7-适用的负载均衡器-2"><a href="#7-适用的负载均衡器-2" class="headerlink" title="7. 适用的负载均衡器"></a><strong>7. 适用的负载均衡器</strong></h2><ul>
<li><strong>Nginx</strong>（<code>least_conn</code> 负载均衡策略）</li>
<li><strong>HAProxy</strong></li>
<li><strong>F5 BIG-IP</strong></li>
<li><strong>Kubernetes Ingress</strong></li>
<li><strong>AWS Elastic Load Balancer（ELB）</strong></li>
</ul>
<hr>
<h2 id="8-配置示例"><a href="#8-配置示例" class="headerlink" title="8. 配置示例"></a><strong>8. 配置示例</strong></h2><h3 id="Nginx-配置最小连接数"><a href="#Nginx-配置最小连接数" class="headerlink" title="Nginx 配置最小连接数"></a><strong>Nginx 配置最小连接数</strong></h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> backend &#123;</span><br><span class="line">    least_conn;</span><br><span class="line">    <span class="attribute">server</span> server1.example.com;</span><br><span class="line">    <span class="attribute">server</span> server2.example.com;</span><br><span class="line">    <span class="attribute">server</span> server3.example.com;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HAProxy-配置最小连接数"><a href="#HAProxy-配置最小连接数" class="headerlink" title="HAProxy 配置最小连接数"></a><strong>HAProxy 配置最小连接数</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">backend servers</span><br><span class="line">    balance leastconn</span><br><span class="line">    server server1 192.168.1.1:80 check</span><br><span class="line">    server server2 192.168.1.2:80 check</span><br><span class="line">    server server3 192.168.1.3:80 check</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a><strong>9. 总结</strong></h2><table>
<thead>
<tr>
<th><strong>算法</strong></th>
<th><strong>特点</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>优缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>轮询（RR）</strong></td>
<td>请求轮流分配</td>
<td>服务器性能相近、请求处理时间短</td>
<td>✅ 简单高效 ❌ 无法感知服务器负载</td>
</tr>
<tr>
<td><strong>加权轮询（WRR）</strong></td>
<td>根据服务器权重分配</td>
<td>服务器性能不同</td>
<td>✅ 考虑服务器性能 ❌ 需要手动配置权重</td>
</tr>
<tr>
<td><strong>最小连接数（LC）</strong></td>
<td>连接数最少的服务器优先</td>
<td>长连接、高并发应用</td>
<td>✅ 负载更均衡 ❌ 需要实时监测连接数</td>
</tr>
<tr>
<td><strong>加权最小连接数（WLC）</strong></td>
<td>连接数最少 + 服务器权重</td>
<td>服务器性能不同、负载波动大</td>
<td>✅ 兼顾性能和负载 ❌ 计算更复杂</td>
</tr>
</tbody></table>
<h3 id="选择建议"><a href="#选择建议" class="headerlink" title="选择建议"></a><strong>选择建议</strong></h3><ul>
<li><strong>短连接</strong>（HTTP 请求）：✅ <strong>轮询（Round Robin）</strong></li>
<li><strong>服务器性能不同</strong>：✅ <strong>加权轮询（WRR）</strong></li>
<li><strong>长连接、多并发</strong>（WebSocket、数据库）：✅ <strong>最小连接数（LC）</strong></li>
<li><strong>长连接 + 服务器性能不同</strong>：✅ <strong>加权最小连接数（WLC）</strong></li>
</ul>
<p><strong>结论</strong>：最小连接数（Least Connections）是一种更智能的负载均衡策略，适合长连接或请求处理时间不均匀的场景。如果服务器性能差异较大，可以结合<strong>加权策略</strong>进一步优化。</p>
<h1 id="加权最小连接数"><a href="#加权最小连接数" class="headerlink" title="加权最小连接数"></a><strong>加权最小连接数</strong></h1><h2 id="1-原理-3"><a href="#1-原理-3" class="headerlink" title="1. 原理"></a><strong>1. 原理</strong></h2><p>加权最小连接数（Weighted Least Connections, WLC）是<strong>最小连接数（LC）<strong><strong>的增强版本，它在选择</strong></strong>当前活跃连接数最少的服务器</strong>时，还会考虑<strong>服务器的权重（Weight）</strong>，权重越高的服务器能承受更多请求。</p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a><strong>工作流程</strong></h3><ol>
<li>负载均衡器维护每台服务器的<strong>活跃连接数</strong>和<strong>权重</strong>。</li>
<li>计算服务器的<strong>加权负载值</strong>： 负载值&#x3D;当前连接数服务器权重负载值 &#x3D; \frac{\text{当前连接数}}{\text{服务器权重}}</li>
<li>选择<strong>负载值最小</strong>的服务器处理新请求。</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><p>假设有 3 台服务器，权重和当前连接数如下：</p>
<table>
<thead>
<tr>
<th>服务器</th>
<th>权重（Weight）</th>
<th>当前连接数（Active Connections）</th>
<th>计算公式</th>
<th>负载值</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>5</td>
<td>10</td>
<td>10 &#x2F; 5</td>
<td>2.0</td>
</tr>
<tr>
<td>B</td>
<td>3</td>
<td>6</td>
<td>6 &#x2F; 3</td>
<td>2.0</td>
</tr>
<tr>
<td>C</td>
<td>2</td>
<td>5</td>
<td>5 &#x2F; 2</td>
<td>2.5</td>
</tr>
</tbody></table>
<p>✅ <strong>负载值最小的服务器 A 和 B</strong> 将优先处理新请求，而 C 由于负载值较高，不会优先分配。</p>
<hr>
<h2 id="2-适用场景-3"><a href="#2-适用场景-3" class="headerlink" title="2. 适用场景"></a><strong>2. 适用场景</strong></h2><p>✅ <strong>服务器性能不同</strong>（如 CPU、内存、带宽等配置不同）<br>✅ <strong>长连接应用</strong>（如 WebSocket、数据库连接池、视频流等）<br>✅ <strong>请求处理时间不均</strong>（如 API 网关、微服务架构）</p>
<hr>
<h2 id="3-优势-3"><a href="#3-优势-3" class="headerlink" title="3. 优势"></a><strong>3. 优势</strong></h2><p>✅ <strong>更智能的负载均衡</strong>，比普通最小连接数（LC）更合理。<br>✅ <strong>适用于长连接</strong>，可以防止某些服务器被过载。<br>✅ <strong>适用于异构服务器</strong>，更高性能的服务器能承受更多流量。</p>
<hr>
<h2 id="4-缺点-3"><a href="#4-缺点-3" class="headerlink" title="4. 缺点"></a><strong>4. 缺点</strong></h2><p>❌ <strong>计算复杂度更高</strong>，需要维护<strong>权重</strong>和<strong>实时连接数</strong>。<br>❌ <strong>可能导致短时间内负载波动</strong>，如果权重调整不当，可能影响分配效果。</p>
<hr>
<h2 id="5-变种-3"><a href="#5-变种-3" class="headerlink" title="5. 变种"></a><strong>5. 变种</strong></h2><ol>
<li><strong>动态加权最小连接数（Dynamic Weighted Least Connections, DWLC）</strong><ul>
<li><strong>动态调整权重</strong>，根据服务器<strong>实时 CPU、内存、响应时间</strong>等指标调整权重，自动优化分配策略。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="6-配置示例"><a href="#6-配置示例" class="headerlink" title="6. 配置示例"></a><strong>6. 配置示例</strong></h2><h3 id="Nginx-配置加权最小连接数"><a href="#Nginx-配置加权最小连接数" class="headerlink" title="Nginx 配置加权最小连接数"></a><strong>Nginx 配置加权最小连接数</strong></h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> backend &#123;</span><br><span class="line">    least_conn;</span><br><span class="line">    <span class="attribute">server</span> server1.example.com weight=<span class="number">5</span>;</span><br><span class="line">    <span class="attribute">server</span> server2.example.com weight=<span class="number">3</span>;</span><br><span class="line">    <span class="attribute">server</span> server3.example.com weight=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HAProxy-配置加权最小连接数"><a href="#HAProxy-配置加权最小连接数" class="headerlink" title="HAProxy 配置加权最小连接数"></a><strong>HAProxy 配置加权最小连接数</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">backend servers</span><br><span class="line">    balance leastconn</span><br><span class="line">    server server1 192.168.1.1:80 check weight 5</span><br><span class="line">    server server2 192.168.1.2:80 check weight 3</span><br><span class="line">    server server3 192.168.1.3:80 check weight 2</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-适用的负载均衡器-3"><a href="#7-适用的负载均衡器-3" class="headerlink" title="7. 适用的负载均衡器"></a><strong>7. 适用的负载均衡器</strong></h2><ul>
<li><strong>Nginx</strong>（支持 <code>least_conn</code> + <code>weight</code>）</li>
<li><strong>HAProxy</strong></li>
<li><strong>F5 BIG-IP</strong></li>
<li><strong>AWS Elastic Load Balancer（ELB）</strong></li>
<li><strong>Kubernetes Ingress</strong></li>
</ul>
<hr>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a><strong>8. 总结</strong></h2><table>
<thead>
<tr>
<th><strong>算法</strong></th>
<th><strong>特点</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>优缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>轮询（RR）</strong></td>
<td>请求轮流分配</td>
<td>服务器性能相近、短请求</td>
<td>✅ 简单高效 ❌ 无法感知服务器负载</td>
</tr>
<tr>
<td><strong>加权轮询（WRR）</strong></td>
<td>根据服务器权重分配</td>
<td>服务器性能不同</td>
<td>✅ 适用于异构环境 ❌ 不考虑实时负载</td>
</tr>
<tr>
<td><strong>最小连接数（LC）</strong></td>
<td>连接数最少的服务器优先</td>
<td>长连接、高并发应用</td>
<td>✅ 负载更均衡 ❌ 不能区分服务器性能</td>
</tr>
<tr>
<td><strong>加权最小连接数（WLC）</strong></td>
<td>连接数最少 + 服务器权重</td>
<td>服务器性能不同、负载波动大</td>
<td>✅ 兼顾性能和负载 ❌ 计算更复杂</td>
</tr>
</tbody></table>
<h3 id="选择建议-1"><a href="#选择建议-1" class="headerlink" title="选择建议"></a><strong>选择建议</strong></h3><ul>
<li><strong>短连接（HTTP 请求）</strong>：✅ <strong>轮询（RR）</strong></li>
<li><strong>服务器性能不同</strong>：✅ <strong>加权轮询（WRR）</strong></li>
<li><strong>长连接、多并发（WebSocket、数据库）</strong>：✅ <strong>最小连接数（LC）</strong></li>
<li><strong>长连接 + 服务器性能不同</strong>：✅ <strong>加权最小连接数（WLC）</strong></li>
</ul>
<p><strong>结论</strong>：加权最小连接数（WLC）是<strong>最小连接数（LC）的优化版</strong>，适用于<strong>异构服务器环境</strong>，可以让高性能服务器处理更多请求，保证整体负载均衡。如果需要更智能的调度，可以结合<strong>动态加权（DWLC）</strong>进一步优化。</p>
<h1 id="源地址哈希"><a href="#源地址哈希" class="headerlink" title="源地址哈希"></a><strong>源地址哈希</strong></h1><h2 id="1-原理-4"><a href="#1-原理-4" class="headerlink" title="1. 原理"></a><strong>1. 原理</strong></h2><p><strong>源地址哈希（IP Hash）<strong><strong>是一种基于</strong></strong>客户端 IP 地址</strong>的负载均衡算法。它通过<strong>对 IP 地址进行哈希计算</strong>，然后根据哈希值将请求固定分配给某台服务器。这样，<strong>相同的客户端 IP 地址始终会访问同一台服务器</strong>，除非服务器故障或配置变更。</p>
<h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a><strong>工作流程</strong></h3><ol>
<li>负载均衡器获取客户端的 IP 地址（如 <code>192.168.1.100</code>）。</li>
<li>通过<strong>哈希函数</strong>计算该 IP 地址的哈希值，例如： hash(192.168.1.100)&#x3D;3\text{hash(192.168.1.100)} &#x3D; 3</li>
<li>根据计算出的哈希值，映射到后端服务器列表：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务器列表: [Server A, Server B, Server C, Server D]</span><br></pre></td></tr></table></figure>

<pre><code>- 哈希值 `3` → **Server D**
</code></pre>
<ol start="4">
<li><strong>相同 IP 地址的请求会始终路由到相同的服务器</strong>，除非该服务器不可用。</li>
</ol>
<hr>
<h2 id="2-适用场景-4"><a href="#2-适用场景-4" class="headerlink" title="2. 适用场景"></a><strong>2. 适用场景</strong></h2><p>✅ <strong>需要会话保持（Session Persistence）</strong>，如用户认证、购物车等。<br>✅ <strong>适用于无状态应用（如 CDN、API 服务器）</strong>，保证同一 IP 请求到相同服务器以提高缓存命中率。<br>✅ <strong>分布式存储系统</strong>（如一致性哈希 + IP Hash）</p>
<hr>
<h2 id="3-优势-4"><a href="#3-优势-4" class="headerlink" title="3. 优势"></a><strong>3. 优势</strong></h2><p>✅ <strong>会话保持（Session Persistence）</strong>：相同用户的请求始终到同一服务器，无需额外的会话同步。<br>✅ <strong>减少负载均衡器的开销</strong>：无需维护连接状态，适合高并发场景。<br>✅ <strong>提高缓存命中率</strong>：适用于 CDN、反向代理等应用。</p>
<hr>
<h2 id="4-缺点-4"><a href="#4-缺点-4" class="headerlink" title="4. 缺点"></a><strong>4. 缺点</strong></h2><p>❌ <strong>服务器变更会影响分配</strong>：如果服务器列表发生变化（增加&#x2F;减少服务器），哈希计算结果会变化，导致大量用户被分配到新服务器，可能丢失会话。<br>❌ <strong>负载不均衡</strong>：IP 地址的分布可能不均匀，导致部分服务器负载较高。<br>❌ <strong>不适用于 NAT 环境</strong>：如果多个用户通过 NAT 共享一个公网 IP，则所有请求都会集中到同一台服务器，造成负载不均。</p>
<hr>
<h2 id="5-变种-4"><a href="#5-变种-4" class="headerlink" title="5. 变种"></a><strong>5. 变种</strong></h2><ol>
<li><strong>一致性哈希（Consistent Hashing）</strong><ul>
<li>服务器增减时，仅影响少部分用户，而不是所有用户，解决了传统 IP Hash 方案的服务器变更问题。</li>
<li>适用于<strong>分布式存储（如 Redis、Memcached）、分布式数据库（如 Cassandra）</strong>等。</li>
</ul>
</li>
<li><strong>加权 IP 哈希（Weighted IP Hash）</strong><ul>
<li>结合服务器权重，使高性能服务器处理更多流量。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="6-示例-3"><a href="#6-示例-3" class="headerlink" title="6. 示例"></a><strong>6. 示例</strong></h2><p>假设有 4 台服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server A, Server B, Server C, Server D</span><br></pre></td></tr></table></figure>

<p>对不同 IP 计算哈希值后，得到分配：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">客户端 IP: 192.168.1.100 → Server A</span><br><span class="line">客户端 IP: 192.168.1.101 → Server C</span><br><span class="line">客户端 IP: 192.168.1.102 → Server B</span><br><span class="line">客户端 IP: 192.168.1.103 → Server D</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果 <strong>服务器 D 故障</strong>，那么 <strong>192.168.1.103</strong> 可能会被重新分配到其他服务器，这会导致会话丢失。</p>
<hr>
<h2 id="7-适用的负载均衡器-4"><a href="#7-适用的负载均衡器-4" class="headerlink" title="7. 适用的负载均衡器"></a><strong>7. 适用的负载均衡器</strong></h2><ul>
<li><strong>Nginx</strong>（<code>ip_hash</code> 负载均衡策略）</li>
<li><strong>HAProxy</strong></li>
<li><strong>F5 BIG-IP</strong></li>
<li><strong>Kubernetes Ingress</strong></li>
<li><strong>CDN（如 Cloudflare、Akamai）</strong></li>
</ul>
<hr>
<h2 id="8-配置示例-1"><a href="#8-配置示例-1" class="headerlink" title="8. 配置示例"></a><strong>8. 配置示例</strong></h2><h3 id="Nginx-配置-IP-Hash"><a href="#Nginx-配置-IP-Hash" class="headerlink" title="Nginx 配置 IP Hash"></a><strong>Nginx 配置 IP Hash</strong></h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> backend &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    <span class="attribute">server</span> server1.example.com;</span><br><span class="line">    <span class="attribute">server</span> server2.example.com;</span><br><span class="line">    <span class="attribute">server</span> server3.example.com;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong><code>ip_hash</code> 不支持动态权重分配，服务器宕机可能会导致流量不均衡。</p>
<h3 id="HAProxy-配置-IP-Hash"><a href="#HAProxy-配置-IP-Hash" class="headerlink" title="HAProxy 配置 IP Hash"></a><strong>HAProxy 配置 IP Hash</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">backend servers</span><br><span class="line">    balance source</span><br><span class="line">    server server1 192.168.1.1:80 check</span><br><span class="line">    server server2 192.168.1.2:80 check</span><br><span class="line">    server server3 192.168.1.3:80 check</span><br></pre></td></tr></table></figure>

<p>这里 <code>balance source</code> 方式使用<strong>客户端 IP 作为哈希源</strong>，实现类似的 IP Hash 负载均衡。</p>
<hr>
<h2 id="9-总结-1"><a href="#9-总结-1" class="headerlink" title="9. 总结"></a><strong>9. 总结</strong></h2><table>
<thead>
<tr>
<th><strong>算法</strong></th>
<th><strong>特点</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>优缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>轮询（RR）</strong></td>
<td>请求轮流分配</td>
<td>服务器性能相近、短请求</td>
<td>✅ 简单高效 ❌ 无法感知服务器负载</td>
</tr>
<tr>
<td><strong>加权轮询（WRR）</strong></td>
<td>根据服务器权重分配</td>
<td>服务器性能不同</td>
<td>✅ 适用于异构环境 ❌ 不考虑实时负载</td>
</tr>
<tr>
<td><strong>最小连接数（LC）</strong></td>
<td>连接数最少的服务器优先</td>
<td>长连接、高并发应用</td>
<td>✅ 负载更均衡 ❌ 不能区分服务器性能</td>
</tr>
<tr>
<td><strong>加权最小连接数（WLC）</strong></td>
<td>连接数最少 + 服务器权重</td>
<td>服务器性能不同、负载波动大</td>
<td>✅ 兼顾性能和负载 ❌ 计算更复杂</td>
</tr>
<tr>
<td><strong>源地址哈希（IP Hash）</strong></td>
<td>相同 IP 访问同一服务器</td>
<td>需要会话保持的场景</td>
<td>✅ 会话保持 ❌ 服务器变更影响大</td>
</tr>
<tr>
<td><strong>一致性哈希（Consistent Hashing）</strong></td>
<td>动态哈希分配</td>
<td>分布式存储、CDN</td>
<td>✅ 服务器扩展性好 ❌ 计算复杂度高</td>
</tr>
</tbody></table>
<h3 id="选择建议-2"><a href="#选择建议-2" class="headerlink" title="选择建议"></a><strong>选择建议</strong></h3><ul>
<li><strong>短连接（HTTP 请求）</strong>：✅ <strong>轮询（RR）</strong></li>
<li><strong>服务器性能不同</strong>：✅ <strong>加权轮询（WRR）</strong></li>
<li><strong>长连接、多并发（WebSocket、数据库）</strong>：✅ <strong>最小连接数（LC）</strong></li>
<li><strong>会话保持（购物车、认证）</strong>：✅ <strong>源地址哈希（IP Hash）</strong></li>
<li><strong>高可用分布式存储</strong>：✅ <strong>一致性哈希（Consistent Hashing）</strong></li>
</ul>
<hr>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h3><p><strong>源地址哈希（IP Hash）</strong> 适用于<strong>需要会话保持</strong>的场景，如用户登录系统、购物车等，但它的<strong>负载均衡效果较差</strong>，并且<strong>服务器变更会影响哈希结果</strong>，导致流量重新分配。<br>如果需要更灵活的负载均衡方案，可以使用<strong>一致性哈希（Consistent Hashing）</strong>，在服务器动态变化时保持较好的稳定性。</p>
<h1 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a><strong>一致性哈希</strong></h1><p>一致性哈希（Consistent Hashing）是一种解决<strong>分布式系统</strong>中节点动态增删对系统影响问题的哈希算法，广泛应用于<strong>分布式缓存</strong>、<strong>分布式存储</strong>、<strong>分布式数据库</strong>等场景。它的关键优势在于能够<strong>最小化节点变化带来的数据迁移和请求转移</strong>。</p>
<h2 id="1-原理-5"><a href="#1-原理-5" class="headerlink" title="1. 原理"></a><strong>1. 原理</strong></h2><p>一致性哈希的核心思想是：将节点（如服务器）和数据（如请求、存储的数据）映射到一个哈希环上，然后通过哈希值来确定数据或请求应该路由到哪台服务器。</p>
<h3 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a><strong>工作流程：</strong></h3><ol>
<li><strong>构建哈希环（Hash Ring）</strong><ul>
<li>使用哈希算法（例如 MD5、SHA-1）将每个服务器的标识符（如 IP 地址、域名）映射到哈希环上的一个位置。这个位置是一个哈希值，通常是一个 32 位或 64 位整数。</li>
<li>假设有 3 台服务器，使用哈希算法将它们映射到哈希环上：</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Server A -&gt; hash(Server A) = 100</span><br><span class="line">Server B -&gt; hash(Server B) = 200</span><br><span class="line">Server C -&gt; hash(Server C) = 300</span><br></pre></td></tr></table></figure>

<p> 这些哈希值构成了一个<strong>哈希环</strong>，例如 <code>[0, 100, 200, 300, 360]</code>。</p>
<ol start="2">
<li><strong>计算请求的哈希值</strong><ul>
<li>客户端请求（如 IP 地址、请求的 URL 或其它唯一标识符）也会经过哈希计算，得出一个哈希值。 <ul>
<li>假设请求的哈希值是 <code>150</code>，它落在 <code>100</code> 和 <code>200</code> 之间，那么它会被分配给<strong>顺时针方向上的第一个服务器</strong>——<code>Server B</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>顺时针查找最近的服务器</strong><ul>
<li>请求会根据哈希值，顺时针查找哈希环上<strong>第一个大于等于该请求哈希值的服务器</strong>。如果该服务器不可用，则会查找下一个服务器。</li>
</ul>
</li>
<li><strong>动态增减服务器</strong><ul>
<li><strong>添加服务器</strong>：当一个新的服务器加入时，只需要重新映射环上某些位置的请求到新服务器，而不会影响到其他请求。 <ul>
<li>例如，如果添加了 <code>Server D</code>，其哈希值为 <code>50</code>，则只有与 <code>Server D</code> 相邻的部分请求会被转移，而其他请求仍然保持不变。</li>
</ul>
</li>
<li><strong>移除服务器</strong>：当一个服务器退出时，只有与该服务器相关联的请求会被迁移到下一个顺时针的服务器，其他请求不受影响。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-适用场景-5"><a href="#2-适用场景-5" class="headerlink" title="2. 适用场景"></a><strong>2. 适用场景</strong></h2><p>一致性哈希特别适用于以下场景：</p>
<ul>
<li><strong>分布式缓存</strong>：如 <code>Redis</code>、<code>Memcached</code>，能有效避免服务器节点增加或减少时带来的大量数据迁移。</li>
<li><strong>分布式存储系统</strong>：如 <code>Cassandra</code>、<code>DynamoDB</code>，实现数据分片和高可用性。</li>
<li><strong>API 网关&#x2F;负载均衡</strong>：保证同一客户端请求始终路由到同一台服务器或节点，避免会话丢失。</li>
<li><strong>内容分发网络（CDN）</strong>：根据用户请求的哈希值将内容请求定向到对应的缓存节点。</li>
</ul>
<hr>
<h2 id="3-优势-5"><a href="#3-优势-5" class="headerlink" title="3. 优势"></a><strong>3. 优势</strong></h2><ol>
<li><strong>动态扩展</strong>：节点的增减对系统的影响最小，仅会影响到哈希环上相邻的一部分请求。</li>
<li><strong>平衡负载</strong>：在理想情况下，一致性哈希保证请求的均匀分布，避免某些节点过载。</li>
<li><strong>减少数据迁移</strong>：相对于传统的哈希方法，数据迁移的范围大大减少，仅需迁移少量数据。</li>
<li><strong>高可用性</strong>：节点失效时，只有少量请求需要迁移到其他服务器，确保系统的容错性。</li>
</ol>
<hr>
<h2 id="4-缺点-5"><a href="#4-缺点-5" class="headerlink" title="4. 缺点"></a><strong>4. 缺点</strong></h2><ol>
<li><strong>负载不完全均匀</strong>：特别是在服务器数量较少时，可能会有节点承担过多请求，而其他节点负载较轻。</li>
<li><strong>虚拟节点问题</strong>：为了提高负载均衡性，通常会使用虚拟节点（每台真实服务器映射多个位置）。虽然虚拟节点能改善负载不均问题，但也增加了实现的复杂性。</li>
<li><strong>性能问题</strong>：计算哈希值、查找最近节点等操作可能对系统的性能产生影响，尤其是在大量请求的高并发情况下。</li>
</ol>
<hr>
<h2 id="5-变种-5"><a href="#5-变种-5" class="headerlink" title="5. 变种"></a><strong>5. 变种</strong></h2><ol>
<li><strong>虚拟节点（Virtual Nodes）</strong><ul>
<li>为了让请求更加均匀地分布到各个服务器上，通常会为每台物理服务器分配多个虚拟节点。每个虚拟节点都映射到哈希环上的一个位置，这样可以更均匀地分配负载。</li>
<li>例如，<code>Server A</code> 可以映射到多个虚拟节点，如 <code>Server A1</code>, <code>Server A2</code>, <code>Server A3</code>，这样就能让负载更加均匀。</li>
</ul>
</li>
<li><strong>一致性哈希 + 加权（Weighted Consistent Hashing）</strong><ul>
<li>结合节点的权重，使得性能更高的服务器可以承担更多的请求。这样，节点的负载不仅与其所在位置相关，还与其权重有关。</li>
</ul>
</li>
<li><strong>一致性哈希 + 分区（Partitioned Consistent Hashing）</strong><ul>
<li>将请求划分为多个子区域，每个区域使用不同的哈希环进行负载均衡。这种方法适合处理不同类型的请求或数据。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="6-示例-4"><a href="#6-示例-4" class="headerlink" title="6. 示例"></a><strong>6. 示例</strong></h2><p>假设有 4 台服务器，哈希环如图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0] ---&gt; [100] --&gt; [200] --&gt; [300] --&gt; [360]</span><br><span class="line">  |        A        B        C        D</span><br></pre></td></tr></table></figure>

<p><strong>步骤 1：</strong> 计算客户端请求 <code>192.168.1.100</code> 的哈希值为 <code>120</code>。<br><strong>步骤 2：</strong> 哈希值 <code>120</code> 顺时针查找，最接近的是 <code>Server B</code>（哈希值为 200），因此请求会被转发给 <code>Server B</code>。</p>
<p><strong>步骤 3：</strong> 假如我们新增了 <code>Server E</code>，它的哈希值为 <code>50</code>。现在只有原来落在 <code>Server A</code> 和 <code>Server B</code> 之间的请求会转发到 <code>Server E</code>，而其他请求会继续由原来的服务器处理。</p>
<hr>
<h2 id="7-适用的负载均衡器-5"><a href="#7-适用的负载均衡器-5" class="headerlink" title="7. 适用的负载均衡器"></a><strong>7. 适用的负载均衡器</strong></h2><ul>
<li><strong>Nginx</strong>：通过插件或自定义模块实现一致性哈希。</li>
<li><strong>HAProxy</strong>：可以通过 <code>balance source</code> 和自定义哈希算法实现一致性哈希。</li>
<li><strong>Redis Cluster</strong>：使用一致性哈希来分布数据，并确保数据均匀分布在各个节点。</li>
<li><strong>Amazon DynamoDB</strong>、<strong>Cassandra</strong>：内部使用一致性哈希来管理数据分片。</li>
</ul>
<hr>
<h2 id="8-配置示例-2"><a href="#8-配置示例-2" class="headerlink" title="8. 配置示例"></a><strong>8. 配置示例</strong></h2><h3 id="Nginx-配置一致性哈希"><a href="#Nginx-配置一致性哈希" class="headerlink" title="Nginx 配置一致性哈希"></a><strong>Nginx 配置一致性哈希</strong></h3><p>Nginx 本身没有直接支持一致性哈希的内置模块，但可以使用第三方模块或自定义脚本来实现。</p>
<h3 id="HAProxy-配置一致性哈希"><a href="#HAProxy-配置一致性哈希" class="headerlink" title="HAProxy 配置一致性哈希"></a><strong>HAProxy 配置一致性哈希</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">backend servers</span><br><span class="line">    balance consistent</span><br><span class="line">    server server1 192.168.1.1:80 check</span><br><span class="line">    server server2 192.168.1.2:80 check</span><br><span class="line">    server server3 192.168.1.3:80 check</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="9-总结-2"><a href="#9-总结-2" class="headerlink" title="9. 总结"></a><strong>9. 总结</strong></h2><table>
<thead>
<tr>
<th><strong>算法</strong></th>
<th><strong>特点</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>优缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>轮询（RR）</strong></td>
<td>请求均匀分配</td>
<td>请求处理时间相近，负载均衡要求较低</td>
<td>✅ 简单高效 ❌ 不考虑服务器负载</td>
</tr>
<tr>
<td><strong>加权轮询（WRR）</strong></td>
<td>根据权重分配请求</td>
<td>服务器性能不同的场景</td>
<td>✅ 考虑服务器性能 ❌ 配置复杂</td>
</tr>
<tr>
<td><strong>最小连接数（LC）</strong></td>
<td>连接数少的服务器优先</td>
<td>长连接、高并发应用</td>
<td>✅ 动态负载分配 ❌ 配置复杂</td>
</tr>
<tr>
<td><strong>一致性哈希（CH）</strong></td>
<td>请求根据哈希值分配到服务器</td>
<td>分布式缓存、分布式数据库、CDN 等</td>
<td>✅ 动态扩展、负载均衡 ❌ 负载不均</td>
</tr>
<tr>
<td><strong>一致性哈希 + 虚拟节点</strong></td>
<td>为每台服务器增加虚拟节点</td>
<td>高负载均衡要求、节点动态变化频繁</td>
<td>✅ 提升均匀性 ❌ 增加复杂性</td>
</tr>
</tbody></table>
<h3 id="选择建议-3"><a href="#选择建议-3" class="headerlink" title="选择建议"></a><strong>选择建议</strong></h3><ul>
<li><strong>服务器动态增加、减少时</strong>：✅ <strong>一致性哈希</strong></li>
<li>**分布式缓存</li>
</ul>
<h1 id="最短响应时间"><a href="#最短响应时间" class="headerlink" title="最短响应时间"></a><strong>最短响应时间</strong></h1><p><strong>最短响应时间（Least Response Time）</strong> 是一种基于服务器响应时间来分配请求的负载均衡策略。它的核心思想是：将请求分配给当前响应时间最短的服务器，从而在处理请求时尽可能减少延迟。</p>
<h2 id="1-原理-6"><a href="#1-原理-6" class="headerlink" title="1. 原理"></a><strong>1. 原理</strong></h2><p>最短响应时间算法的工作原理是：</p>
<ul>
<li>每个服务器的响应时间（即它处理请求的平均时间或当前处理请求的时间）会被实时监控。</li>
<li>每当有新的请求到达负载均衡器时，<strong>负载均衡器会将请求分配给响应时间最短的服务器</strong>，即当前负载最轻的服务器。</li>
<li>这意味着，服务器响应时间短并不代表它处理能力强，而是它当前没有太多请求排队，能够迅速响应。</li>
</ul>
<hr>
<h2 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2. 工作流程"></a><strong>2. 工作流程</strong></h2><ol>
<li><strong>监控每台服务器的响应时间</strong><ul>
<li>负载均衡器持续监控每台服务器的响应时间或处理请求的速度。常见的监控指标有：每台服务器的<strong>平均响应时间</strong>、<strong>当前连接数</strong>等。</li>
</ul>
</li>
<li><strong>选择响应时间最短的服务器</strong><ul>
<li>当有新的请求到达负载均衡器时，系统会检查所有服务器的响应时间，将请求分配给响应时间最短的服务器。例如，如果 <code>Server A</code> 的响应时间是 100ms，<code>Server B</code> 的响应时间是 50ms，那么请求将被分配给 <code>Server B</code>。</li>
</ul>
</li>
<li><strong>实时更新服务器状态</strong><ul>
<li>负载均衡器不断更新服务器的响应时间，适应系统负载的变化，并动态调整请求分配。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3. 适用场景"></a><strong>3. 适用场景</strong></h2><p>✅ <strong>低延迟要求的应用</strong>：当应用对请求响应时间有严格要求时，如实时系统、视频流、在线游戏等。<br>✅ <strong>流量不均、负载波动较大的场景</strong>：此算法能够根据实时响应时间动态调整流量分配，适应不同的负载波动。<br>✅ <strong>会话持续性较低的应用</strong>：适用于对会话保持要求不高的场景，如某些短时间的 API 请求。</p>
<hr>
<h2 id="4-优势"><a href="#4-优势" class="headerlink" title="4. 优势"></a><strong>4. 优势</strong></h2><p>✅ <strong>减少延迟</strong>：通过选择响应时间最短的服务器，尽可能减少请求的响应延迟，提升用户体验。<br>✅ <strong>适应负载波动</strong>：响应时间的变化能反映当前服务器的负载情况，能够动态调整流量分配，适应高并发和负载波动。<br>✅ <strong>避免服务器过载</strong>：如果某个服务器的响应时间较长（表明其负载较重），新的请求就会被分配给其他响应时间较短的服务器，避免了过载问题。</p>
<hr>
<h2 id="5-缺点"><a href="#5-缺点" class="headerlink" title="5. 缺点"></a><strong>5. 缺点</strong></h2><p>❌ <strong>难以准确度量响应时间</strong>：实际中，响应时间受很多因素影响，包括网络延迟、服务器健康状况等，可能导致实时的响应时间监控不完全准确。<br>❌ <strong>对服务器状态依赖较大</strong>：该算法过于依赖实时的响应时间数据，可能在服务器启动阶段或短时间内出现不稳定的响应时间波动。<br>❌ <strong>不考虑服务器的处理能力</strong>：响应时间短的服务器并不意味着它处理能力强，可能是因为该服务器当前负载较少，而不代表它能持续处理更多请求。<br>❌ <strong>可能导致会话不稳定</strong>：如果请求分配是基于实时响应时间，某些用户可能会因为负载变化而在不同的服务器之间切换，导致会话丢失，影响用户体验。</p>
<hr>
<h2 id="6-与其他算法比较"><a href="#6-与其他算法比较" class="headerlink" title="6. 与其他算法比较"></a><strong>6. 与其他算法比较</strong></h2><table>
<thead>
<tr>
<th><strong>负载均衡算法</strong></th>
<th><strong>特点</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>优缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>轮询（Round Robin）</strong></td>
<td>请求轮流分配</td>
<td>简单、高效，负载均匀的场景</td>
<td>✅ 实现简单 ❌ 无法根据负载调整</td>
</tr>
<tr>
<td><strong>最小连接数（Least Connections）</strong></td>
<td>选择连接数最少的服务器</td>
<td>长连接、高并发应用</td>
<td>✅ 负载均衡性较好 ❌ 不能应对短连接负载波动</td>
</tr>
<tr>
<td><strong>最短响应时间（Least Response Time）</strong></td>
<td>选择响应时间最短的服务器</td>
<td>低延迟要求、负载波动大的应用</td>
<td>✅ 动态适应负载波动 ❌ 过于依赖实时响应监控</td>
</tr>
<tr>
<td><strong>加权轮询（Weighted Round Robin）</strong></td>
<td>根据服务器权重分配请求</td>
<td>服务器性能差异较大</td>
<td>✅ 性能差异处理好 ❌ 不考虑实时负载</td>
</tr>
<tr>
<td><strong>加权最小连接数（Weighted Least Connections）</strong></td>
<td>根据连接数和权重分配请求</td>
<td>服务器性能差异较大、负载变化大的场景</td>
<td>✅ 兼顾负载和性能 ❌ 配置复杂</td>
</tr>
</tbody></table>
<hr>
<h2 id="7-配置示例"><a href="#7-配置示例" class="headerlink" title="7. 配置示例"></a><strong>7. 配置示例</strong></h2><h3 id="Nginx-配置最短响应时间"><a href="#Nginx-配置最短响应时间" class="headerlink" title="Nginx 配置最短响应时间"></a><strong>Nginx 配置最短响应时间</strong></h3><p>Nginx 本身不直接支持最短响应时间负载均衡，但可以通过第三方模块（如 <code>nginx_upstream_least_time</code>）来实现。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">upstream</span> backend &#123;</span><br><span class="line">        least_time;</span><br><span class="line">        <span class="attribute">server</span> backend1.example.com;</span><br><span class="line">        <span class="attribute">server</span> backend2.example.com;</span><br><span class="line">        <span class="attribute">server</span> backend3.example.com;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>least_time</code> 指定了最短响应时间算法，Nginx 会根据服务器响应时间将请求分配给响应时间最短的服务器。</p>
<h3 id="HAProxy-配置最短响应时间"><a href="#HAProxy-配置最短响应时间" class="headerlink" title="HAProxy 配置最短响应时间"></a><strong>HAProxy 配置最短响应时间</strong></h3><p>HAProxy 提供了 <code>balance rtt</code>（Round Trip Time）策略，用于基于响应时间来平衡负载。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">backend servers</span><br><span class="line">    balance rtt</span><br><span class="line">    server server1 192.168.1.1:80 check</span><br><span class="line">    server server2 192.168.1.2:80 check</span><br><span class="line">    server server3 192.168.1.3:80 check</span><br></pre></td></tr></table></figure>

<p><code>balance rtt</code> 指定了基于响应时间的负载均衡策略，HAProxy 会自动选择响应时间最短的服务器。</p>
<hr>
<h2 id="8-总结-1"><a href="#8-总结-1" class="headerlink" title="8. 总结"></a><strong>8. 总结</strong></h2><table>
<thead>
<tr>
<th><strong>算法</strong></th>
<th><strong>特点</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>优缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>轮询（RR）</strong></td>
<td>请求均匀分配</td>
<td>服务器负载均衡较好，适用于无状态应用</td>
<td>✅ 简单高效 ❌ 不考虑服务器负载</td>
</tr>
<tr>
<td><strong>最小连接数（LC）</strong></td>
<td>选择连接数最少的服务器</td>
<td>长连接、高并发应用</td>
<td>✅ 负载均衡 ❌ 适应不了响应时间变化</td>
</tr>
<tr>
<td><strong>最短响应时间（LRT）</strong></td>
<td>根据响应时间分配请求</td>
<td>低延迟要求的场景，适应负载波动的应用</td>
<td>✅ 高效动态 ❌ 依赖实时响应监控，过于简单</td>
</tr>
<tr>
<td><strong>加权最小连接数（WLC）</strong></td>
<td>根据连接数和权重进行分配</td>
<td>异构服务器、动态负载应用</td>
<td>✅ 动态权重 ❌ 计算复杂</td>
</tr>
</tbody></table>
<h3 id="选择建议-4"><a href="#选择建议-4" class="headerlink" title="选择建议"></a><strong>选择建议</strong></h3><ul>
<li><strong>低延迟、高响应要求的应用</strong>：✅ <strong>最短响应时间（Least Response Time）</strong></li>
<li><strong>高并发、长连接应用</strong>：✅ <strong>最小连接数（Least Connections）</strong></li>
<li><strong>无状态请求和负载均匀应用</strong>：✅ <strong>轮询（Round Robin）</strong></li>
</ul>
<h1 id="随机"><a href="#随机" class="headerlink" title="随机"></a><strong>随机</strong></h1><p><strong>随机负载均衡算法（Random Load Balancing）</strong> 是一种非常简单且直接的负载均衡策略。它通过<strong>随机选择</strong>一台服务器来处理请求，无需考虑任何关于服务器负载、连接数或响应时间的因素。</p>
<h2 id="1-原理-7"><a href="#1-原理-7" class="headerlink" title="1. 原理"></a><strong>1. 原理</strong></h2><p>随机负载均衡的核心原理是：</p>
<ul>
<li><strong>每个请求都被随机分配</strong>到某台可用的服务器。</li>
<li>它并不会依据服务器的当前状态（如负载、响应时间、连接数等）来做任何优化，而是完全依赖于随机性。</li>
</ul>
<h3 id="工作流程：-1"><a href="#工作流程：-1" class="headerlink" title="工作流程："></a><strong>工作流程：</strong></h3><ol>
<li><strong>所有服务器可用</strong>：首先，负载均衡器会获取所有可用的服务器列表。</li>
<li><strong>随机选择服务器</strong>：每当有一个请求到来时，负载均衡器会从服务器列表中<strong>随机选择一台服务器</strong>来处理该请求。</li>
<li><strong>请求转发</strong>：请求被转发到选中的服务器。</li>
</ol>
<p>这种方式非常直接，常见于负载不均的环境或不需要高性能、高可用性的场景。</p>
<hr>
<h2 id="2-适用场景-6"><a href="#2-适用场景-6" class="headerlink" title="2. 适用场景"></a><strong>2. 适用场景</strong></h2><p>✅ <strong>负载均衡需求不高的简单应用</strong>：如一些小型网站或测试环境中，负载不大，服务器状态差异不明显。<br>✅ <strong>高并发但无复杂状态要求的应用</strong>：如静态文件服务器、某些内容分发网络（CDN）等，随机分配对系统性能影响不大。<br>✅ <strong>简单性要求较高的系统</strong>：如果系统设计需要极简的实现方式，且对负载均衡策略要求不高，随机负载均衡是一个不错的选择。</p>
<hr>
<h2 id="3-优势-6"><a href="#3-优势-6" class="headerlink" title="3. 优势"></a><strong>3. 优势</strong></h2><p>✅ <strong>简单易实现</strong>：随机负载均衡算法非常简单，易于理解和实现。它不需要记录服务器的状态信息，也不依赖额外的监控系统或算法，减少了系统复杂性。<br>✅ <strong>无状态特性</strong>：适用于无状态的服务，每个请求都是独立的，随机选择服务器不会影响后续请求的处理。<br>✅ <strong>适合负载均匀的场景</strong>：在负载比较均衡或服务器性能相差不大的情况下，随机分配可以有效避免复杂的负载计算过程。</p>
<hr>
<h2 id="4-缺点-6"><a href="#4-缺点-6" class="headerlink" title="4. 缺点"></a><strong>4. 缺点</strong></h2><p>❌ <strong>负载不均</strong>：随机算法不考虑服务器的当前负载、响应时间等因素，可能会导致部分服务器过载，而其他服务器空闲，从而造成不均衡的负载分配。<br>❌ <strong>无适应性</strong>：随着系统负载的变化，随机算法并不能动态调整负载分配方式，可能无法在高流量情况下充分利用每台服务器的处理能力。<br>❌ <strong>不能应对服务器差异</strong>：当服务器性能差异较大时，随机算法不会考虑性能差异，可能将请求分配给处理能力较弱的服务器，影响整体性能。</p>
<hr>
<h2 id="5-与其他算法比较"><a href="#5-与其他算法比较" class="headerlink" title="5. 与其他算法比较"></a><strong>5. 与其他算法比较</strong></h2><table>
<thead>
<tr>
<th><strong>负载均衡算法</strong></th>
<th><strong>特点</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>优缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>轮询（Round Robin）</strong></td>
<td>请求轮流分配</td>
<td>请求处理时间相近，负载均衡要求较低</td>
<td>✅ 实现简单 ❌ 无法根据负载调整</td>
</tr>
<tr>
<td><strong>最小连接数（Least Connections）</strong></td>
<td>选择连接数最少的服务器</td>
<td>长连接、高并发应用</td>
<td>✅ 负载均衡性较好 ❌ 不能应对短连接负载波动</td>
</tr>
<tr>
<td><strong>最短响应时间（Least Response Time）</strong></td>
<td>选择响应时间最短的服务器</td>
<td>低延迟要求、负载波动大的应用</td>
<td>✅ 动态适应负载波动 ❌ 过于依赖实时响应监控</td>
</tr>
<tr>
<td><strong>加权轮询（Weighted Round Robin）</strong></td>
<td>根据服务器权重分配请求</td>
<td>服务器性能差异较大</td>
<td>✅ 性能差异处理好 ❌ 不考虑实时负载</td>
</tr>
<tr>
<td><strong>随机（Random）</strong></td>
<td>请求随机分配</td>
<td>负载均匀、性能差异不大的场景</td>
<td>✅ 实现简单 ❌ 无法保证负载均衡</td>
</tr>
</tbody></table>
<hr>
<h2 id="6-配置示例-1"><a href="#6-配置示例-1" class="headerlink" title="6. 配置示例"></a><strong>6. 配置示例</strong></h2><h3 id="Nginx-配置随机负载均衡"><a href="#Nginx-配置随机负载均衡" class="headerlink" title="Nginx 配置随机负载均衡"></a><strong>Nginx 配置随机负载均衡</strong></h3><p>在 Nginx 中实现随机负载均衡，可以使用 <code>random</code> 均衡方式。以下是简单的 Nginx 配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">upstream</span> backend &#123;</span><br><span class="line">        random;</span><br><span class="line">        <span class="attribute">server</span> backend1.example.com;</span><br><span class="line">        <span class="attribute">server</span> backend2.example.com;</span><br><span class="line">        <span class="attribute">server</span> backend3.example.com;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HAProxy-配置随机负载均衡"><a href="#HAProxy-配置随机负载均衡" class="headerlink" title="HAProxy 配置随机负载均衡"></a><strong>HAProxy 配置随机负载均衡</strong></h3><p>HAProxy 也支持随机负载均衡，可以通过 <code>balance random</code> 来配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">backend servers</span><br><span class="line">    balance random</span><br><span class="line">    server server1 192.168.1.1:80 check</span><br><span class="line">    server server2 192.168.1.2:80 check</span><br><span class="line">    server server3 192.168.1.3:80 check</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a><strong>7. 总结</strong></h2><table>
<thead>
<tr>
<th><strong>算法</strong></th>
<th><strong>特点</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>优缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>轮询（Round Robin）</strong></td>
<td>请求均匀分配</td>
<td>负载均衡要求较低、服务器性能相似的场景</td>
<td>✅ 简单高效 ❌ 无法根据负载调整</td>
</tr>
<tr>
<td><strong>最小连接数（Least Connections）</strong></td>
<td>连接数最少的服务器优先</td>
<td>长连接、高并发应用</td>
<td>✅ 适应性强 ❌ 无法适应短连接波动</td>
</tr>
<tr>
<td><strong>最短响应时间（Least Response Time）</strong></td>
<td>响应时间最短的服务器优先</td>
<td>高响应要求、负载波动较大的场景</td>
<td>✅ 动态调整负载 ❌ 高依赖实时监控</td>
</tr>
<tr>
<td><strong>加权轮询（Weighted Round Robin）</strong></td>
<td>根据权重分配请求</td>
<td>性能差异较大的场景</td>
<td>✅ 权重处理好 ❌ 配置复杂</td>
</tr>
<tr>
<td><strong>随机（Random）</strong></td>
<td>请求随机分配</td>
<td>负载均衡不严格的场景</td>
<td>✅ 简单实现 ❌ 可能导致不均衡</td>
</tr>
</tbody></table>
<h3 id="选择建议-5"><a href="#选择建议-5" class="headerlink" title="选择建议"></a><strong>选择建议</strong></h3><ul>
<li><strong>对负载均衡要求较低的简单应用</strong>：✅ <strong>随机（Random）</strong></li>
<li><strong>负载波动较大，需要动态调整的应用</strong>：✅ <strong>最小连接数（Least Connections）</strong> 或 <strong>最短响应时间（Least Response Time）</strong></li>
<li><strong>性能差异明显，需要处理负载的应用</strong>：✅ <strong>加权轮询（Weighted Round Robin）</strong></li>
</ul>
<h1 id="负载感知"><a href="#负载感知" class="headerlink" title="负载感知"></a><strong>负载感知</strong></h1><p><strong>负载感知（Adaptive Load Balancing，ALB）</strong> 是一种智能化的负载均衡算法，它根据每台服务器的实时负载状况、性能指标等信息来动态调整流量的分配。与传统的静态负载均衡算法（如轮询、随机等）不同，负载感知算法能够感知服务器的负载变化，并作出适应性调整。</p>
<h2 id="1-原理-8"><a href="#1-原理-8" class="headerlink" title="1. 原理"></a><strong>1. 原理</strong></h2><p>负载感知负载均衡的基本原理是：</p>
<ul>
<li><strong>动态监控</strong>：实时监控每台服务器的负载信息，包括 CPU 使用率、内存占用、网络带宽、响应时间、当前连接数等多个指标。</li>
<li><strong>智能决策</strong>：根据这些监控数据，负载均衡器会对请求流量进行动态分配。例如，当某台服务器负载较高时，负载均衡器会将更多的请求分配给负载较低的服务器。</li>
<li><strong>自适应调整</strong>：负载感知算法可以随着负载情况的变化自动调整流量分配策略，最大化利用服务器资源，并尽量避免过载或性能瓶颈。</li>
</ul>
<hr>
<h2 id="2-工作流程-1"><a href="#2-工作流程-1" class="headerlink" title="2. 工作流程"></a><strong>2. 工作流程</strong></h2><ol>
<li><strong>实时数据采集</strong>：负载均衡器持续收集每台服务器的关键性能指标，如响应时间、CPU 使用率、内存使用、带宽利用率等。</li>
<li><strong>负载评估</strong>：负载均衡器通过加权算法或其他规则对服务器的负载进行评估，判断哪些服务器处于空闲、适中或过载状态。</li>
<li><strong>动态流量分配</strong>：基于评估结果，负载均衡器将流量动态地分配给当前负载最适中的服务器。例如，如果某台服务器的 CPU 使用率超过 80%，它可能会被标记为“高负载”，从而减少它的请求分配量。</li>
<li><strong>自适应调整</strong>：如果负载发生变化（例如某台服务器负载下降或其他服务器过载），负载均衡器会实时调整流量分配策略，以确保各台服务器负载均衡。</li>
</ol>
<hr>
<h2 id="3-适用场景-1"><a href="#3-适用场景-1" class="headerlink" title="3. 适用场景"></a><strong>3. 适用场景</strong></h2><p>✅ <strong>高流量、负载波动大的环境</strong>：例如云计算环境、微服务架构等，负载感知算法能够根据实时数据调整负载均衡，优化资源利用。<br>✅ <strong>高可用性要求的应用</strong>：负载感知可以有效避免单点过载，减少某些节点宕机对整体系统性能的影响。<br>✅ <strong>具有多维度性能指标的系统</strong>：如果需要根据多个指标（如 CPU、内存、网络等）来评估服务器负载，负载感知算法可以提供更灵活的流量分配。<br>✅ <strong>复杂应用的高效调度</strong>：例如数据库集群、大规模分布式系统等，能够依据每台服务器的实时负载调度任务，优化整体性能。</p>
<hr>
<h2 id="4-优势-1"><a href="#4-优势-1" class="headerlink" title="4. 优势"></a><strong>4. 优势</strong></h2><p>✅ <strong>动态适应</strong>：负载感知算法能够实时响应服务器的负载变化，从而实现智能的流量分配，减少过载或资源浪费。<br>✅ <strong>高效利用资源</strong>：通过对负载的动态评估和流量调整，负载感知算法能最大化地利用每台服务器的计算资源，提升整体系统的处理能力。<br>✅ <strong>提高系统稳定性</strong>：通过有效避免单台服务器过载，减少了因某台服务器宕机或性能下降导致的服务中断，提升了系统的稳定性和可用性。<br>✅ <strong>灵活的负载评估方式</strong>：可以根据多个性能指标进行评估，避免了仅依赖单一指标（如连接数、响应时间等）可能带来的负载不均衡问题。</p>
<hr>
<h2 id="5-缺点-1"><a href="#5-缺点-1" class="headerlink" title="5. 缺点"></a><strong>5. 缺点</strong></h2><p>❌ <strong>计算开销较大</strong>：由于需要实时监控多个服务器的多维度负载信息，并根据负载动态调整流量分配，可能会带来一定的计算和网络开销。<br>❌ <strong>配置复杂</strong>：为了能够准确评估和调整负载，负载感知算法需要更加复杂的配置和性能监控，增加了系统的复杂度。<br>❌ <strong>可能的延迟</strong>：虽然能够实现负载均衡，但由于实时监控和负载评估的过程可能引入一定的延迟，导致请求分配时存在一定的响应时间延迟。<br>❌ <strong>依赖监控数据的准确性</strong>：算法的效果依赖于负载监控数据的准确性和实时性。如果监控数据存在误差或延迟，可能会影响流量分配的正确性。</p>
<hr>
<h2 id="6-与其他算法比较-1"><a href="#6-与其他算法比较-1" class="headerlink" title="6. 与其他算法比较"></a><strong>6. 与其他算法比较</strong></h2><table>
<thead>
<tr>
<th><strong>负载均衡算法</strong></th>
<th><strong>特点</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>优缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>轮询（Round Robin）</strong></td>
<td>请求轮流分配</td>
<td>请求负载均匀、无状态应用</td>
<td>✅ 实现简单 ❌ 无法根据负载动态调整</td>
</tr>
<tr>
<td><strong>最小连接数（Least Connections）</strong></td>
<td>选择连接数最少的服务器</td>
<td>长连接、高并发应用</td>
<td>✅ 适应性较好 ❌ 无法处理响应时间波动</td>
</tr>
<tr>
<td><strong>最短响应时间（Least Response Time）</strong></td>
<td>选择响应时间最短的服务器</td>
<td>低延迟要求、负载波动较大的应用</td>
<td>✅ 动态适应负载波动 ❌ 高依赖实时响应监控</td>
</tr>
<tr>
<td><strong>加权轮询（Weighted Round Robin）</strong></td>
<td>根据权重分配请求</td>
<td>服务器性能差异较大的场景</td>
<td>✅ 适合性能差异大的场景 ❌ 配置复杂</td>
</tr>
<tr>
<td><strong>负载感知（Adaptive Load Balancing）</strong></td>
<td>根据实时负载调整流量分配</td>
<td>高负载波动、大规模分布式系统</td>
<td>✅ 动态调整 ❌ 计算和配置复杂</td>
</tr>
</tbody></table>
<hr>
<h2 id="7-配置示例-1"><a href="#7-配置示例-1" class="headerlink" title="7. 配置示例"></a><strong>7. 配置示例</strong></h2><h3 id="Nginx-配置负载感知负载均衡"><a href="#Nginx-配置负载感知负载均衡" class="headerlink" title="Nginx 配置负载感知负载均衡"></a><strong>Nginx 配置负载感知负载均衡</strong></h3><p>Nginx 本身不直接支持负载感知负载均衡，但可以通过第三方模块实现。例如，<code>nginx_upstream_module</code> 支持基于负载的流量调整。要使用负载感知算法，通常需要更复杂的配置，或者集成外部监控与调度系统来帮助动态调整流量。</p>
<h3 id="HAProxy-配置负载感知负载均衡"><a href="#HAProxy-配置负载感知负载均衡" class="headerlink" title="HAProxy 配置负载感知负载均衡"></a><strong>HAProxy 配置负载感知负载均衡</strong></h3><p>在 HAProxy 中，负载感知算法通常通过结合权重、连接数和响应时间来实现自适应调整。配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">backend servers</span><br><span class="line">    balance leastconn  # 基于连接数选择最少连接数的服务器</span><br><span class="line">    server server1 192.168.1.1:80 check weight 1</span><br><span class="line">    server server2 192.168.1.2:80 check weight 2</span><br><span class="line">    server server3 192.168.1.3:80 check weight 3</span><br></pre></td></tr></table></figure>

<p>此外，使用外部监控系统（如 Prometheus、Datadog 等）结合 HAProxy 或其他负载均衡器，也可以实现实时的负载评估和自适应流量分配。</p>
<hr>
<h2 id="8-总结-2"><a href="#8-总结-2" class="headerlink" title="8. 总结"></a><strong>8. 总结</strong></h2><table>
<thead>
<tr>
<th><strong>算法</strong></th>
<th><strong>特点</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>优缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>轮询（Round Robin）</strong></td>
<td>请求均匀分配</td>
<td>无状态应用、高并发</td>
<td>✅ 简单高效 ❌ 无法根据负载调整</td>
</tr>
<tr>
<td><strong>最小连接数（Least Connections）</strong></td>
<td>选择连接数最少的服务器</td>
<td>长连接应用、高并发</td>
<td>✅ 适应性较好 ❌ 不能处理负载变化</td>
</tr>
<tr>
<td><strong>负载感知（Adaptive Load Balancing）</strong></td>
<td>动态调整负载、实时评估服务器状态</td>
<td>高负载波动、大规模分布式系统</td>
<td>✅ 动态调整、实时适应 ❌ 计算和配置复杂</td>
</tr>
</tbody></table>
<h3 id="选择建议-6"><a href="#选择建议-6" class="headerlink" title="选择建议"></a><strong>选择建议</strong></h3><ul>
<li><strong>需要实时调整负载、适应性强的应用</strong>：✅ <strong>负载感知（Adaptive Load Balancing）</strong></li>
<li><strong>负载较均衡的简单应用</strong>：✅ <strong>轮询（Round Robin）</strong></li>
<li><strong>长连接且负载变化不大的应用</strong>：✅ <strong>最小连接数（Least Connections）</strong></li>
</ul>
<h1 id="动态反馈算法"><a href="#动态反馈算法" class="headerlink" title="动态反馈算法"></a><strong>动态反馈算法</strong></h1><p><strong>动态反馈算法（DFA）</strong> 是一种智能化的负载均衡策略，它通过持续收集系统中各个服务器的负载信息，并根据这些信息动态调整流量分配。与传统的负载均衡算法不同，DFA 强调<strong>动态反馈</strong>，即根据服务器的性能变化和负载状态来做出实时的调整。这种算法广泛应用于那些需要对服务器状态进行实时监控和调节的高并发、高负载的系统中。</p>
<h2 id="1-原理-9"><a href="#1-原理-9" class="headerlink" title="1. 原理"></a><strong>1. 原理</strong></h2><p>动态反馈算法的基本原理是：</p>
<ul>
<li><strong>实时监控</strong>：持续监控每台服务器的运行状态，包括但不限于 CPU 使用率、内存使用量、响应时间、网络带宽、连接数等。</li>
<li><strong>实时反馈</strong>：基于对各服务器状态的实时监控，系统反馈负载信息，负载均衡器根据这些信息动态调整流量的分配。</li>
<li><strong>动态调整</strong>：负载均衡器依据反馈的负载数据做出动态调整。当某台服务器负载过高时，流量会被更多地转发到负载较轻的服务器，反之亦然。</li>
</ul>
<p>DFA 的核心是“反馈”机制，即系统能根据服务器的实时负载情况，快速地调整负载均衡策略，保持系统的高效运行。</p>
<hr>
<h2 id="2-工作流程-2"><a href="#2-工作流程-2" class="headerlink" title="2. 工作流程"></a><strong>2. 工作流程</strong></h2><ol>
<li><strong>实时数据收集</strong>：负载均衡器持续收集服务器的性能数据，通常包括：<ul>
<li>CPU 使用率</li>
<li>内存占用</li>
<li>网络带宽</li>
<li>响应时间</li>
<li>当前连接数</li>
<li>错误率等</li>
</ul>
</li>
<li><strong>负载反馈机制</strong>：根据实时数据，系统会对每台服务器的当前负载进行评估。这些反馈信息将传递给负载均衡器，作为决策依据。</li>
<li><strong>调整流量分配</strong>：负载均衡器会根据反馈信息重新调整流量分配。例如，当某台服务器负载过高时，负载均衡器会减少它接收的请求，反之则可能增加它的请求数。</li>
<li><strong>自适应变化</strong>：随着负载的变化，DFA 会不断地收集新的反馈数据，并根据新的信息实时调整流量分配，以确保系统稳定、性能优化。</li>
</ol>
<hr>
<h2 id="3-适用场景-2"><a href="#3-适用场景-2" class="headerlink" title="3. 适用场景"></a><strong>3. 适用场景</strong></h2><p>✅ <strong>高负载波动、大规模系统</strong>：当系统中负载波动较大，或者有大量请求需要动态调整时，DFA 能有效平衡负载，避免某些服务器过载。<br>✅ <strong>微服务架构或容器化环境</strong>：在微服务架构中，不同服务实例的负载可能变化较大，DFA 可以根据每个实例的实时负载状况调整流量分配。<br>✅ <strong>需要快速反应负载变化的系统</strong>：例如流量突增的情况（如电商促销活动期间），DFA 可以迅速做出响应，确保服务不中断。<br>✅ <strong>资源分配细粒度控制</strong>：当系统需要精确管理每台服务器的资源使用时，DFA 通过反馈机制能实现细粒度的负载均衡。</p>
<hr>
<h2 id="4-优势-2"><a href="#4-优势-2" class="headerlink" title="4. 优势"></a><strong>4. 优势</strong></h2><p>✅ <strong>智能动态调整</strong>：DFA 根据实时负载数据做出决策，能够适应负载变化，提供更加灵活和高效的负载均衡。<br>✅ <strong>提高系统稳定性</strong>：通过避免单个服务器过载，DFA 有助于提高系统的稳定性和可用性。<br>✅ <strong>减少资源浪费</strong>：通过动态调整流量分配，DFA 能够最大化地利用服务器的资源，减少系统资源的浪费。<br>✅ <strong>适应性强</strong>：DFA 可以应对各种复杂场景，包括系统负载波动、服务器性能差异、突发流量等，能够有效优化资源分配。</p>
<hr>
<h2 id="5-缺点-2"><a href="#5-缺点-2" class="headerlink" title="5. 缺点"></a><strong>5. 缺点</strong></h2><p>❌ <strong>计算开销较大</strong>：由于需要持续监控并分析各个服务器的实时负载数据，DFA 可能会带来一定的计算开销。<br>❌ <strong>实现复杂</strong>：DFA 需要结合实时监控系统、负载均衡算法和反馈机制，因此系统实现较为复杂，需要较高的运维成本。<br>❌ <strong>延迟问题</strong>：实时反馈和动态调整可能会引入一定的延迟，尤其是在负载较重时，可能会影响系统响应时间。<br>❌ <strong>依赖监控精度</strong>：DFA 对监控数据的精度要求较高，若监控数据不准确或延迟，可能会导致流量分配不合理，影响系统性能。</p>
<hr>
<h2 id="6-与其他算法比较-2"><a href="#6-与其他算法比较-2" class="headerlink" title="6. 与其他算法比较"></a><strong>6. 与其他算法比较</strong></h2><table>
<thead>
<tr>
<th><strong>负载均衡算法</strong></th>
<th><strong>特点</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>优缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>轮询（Round Robin）</strong></td>
<td>请求轮流分配</td>
<td>请求负载均匀、无状态应用</td>
<td>✅ 实现简单 ❌ 无法根据负载动态调整</td>
</tr>
<tr>
<td><strong>最小连接数（Least Connections）</strong></td>
<td>选择连接数最少的服务器</td>
<td>长连接、高并发应用</td>
<td>✅ 适应性较好 ❌ 无法处理负载变化</td>
</tr>
<tr>
<td><strong>负载感知（Adaptive Load Balancing）</strong></td>
<td>根据实时负载调整流量分配</td>
<td>高负载波动、大规模分布式系统</td>
<td>✅ 动态调整 ❌ 计算和配置复杂</td>
</tr>
<tr>
<td><strong>动态反馈算法（DFA）</strong></td>
<td>持续收集负载数据并根据反馈动态调整流量</td>
<td>高并发、高负载波动的场景</td>
<td>✅ 动态反馈、灵活调整 ❌ 实现和计算复杂</td>
</tr>
</tbody></table>
<hr>
<h2 id="7-配置示例-2"><a href="#7-配置示例-2" class="headerlink" title="7. 配置示例"></a><strong>7. 配置示例</strong></h2><h3 id="Nginx-配置动态反馈负载均衡"><a href="#Nginx-配置动态反馈负载均衡" class="headerlink" title="Nginx 配置动态反馈负载均衡"></a><strong>Nginx 配置动态反馈负载均衡</strong></h3><p>Nginx 本身不直接支持动态反馈负载均衡，但可以通过使用第三方模块或集成外部负载均衡系统来实现类似功能。可以通过结合监控系统（如 Prometheus 或 Datadog）与负载均衡器实现动态反馈。</p>
<h3 id="HAProxy-配置动态反馈负载均衡"><a href="#HAProxy-配置动态反馈负载均衡" class="headerlink" title="HAProxy 配置动态反馈负载均衡"></a><strong>HAProxy 配置动态反馈负载均衡</strong></h3><p>HAProxy 本身也不直接提供 DFA 支持，但可以结合其他负载均衡和监控方案来实现动态流量调整。以下是一个结合最小连接数和权重的负载均衡配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">backend servers</span><br><span class="line">    balance leastconn  # 基于连接数进行负载均衡</span><br><span class="line">    option http-server-close</span><br><span class="line">    server server1 192.168.1.1:80 check weight 1</span><br><span class="line">    server server2 192.168.1.2:80 check weight 2</span><br><span class="line">    server server3 192.168.1.3:80 check weight 3</span><br></pre></td></tr></table></figure>

<p>在此配置中，<code>leastconn</code> 结合服务器的权重动态分配流量，虽然这与 DFA 略有不同，但可以实现某种程度的动态负载均衡。</p>
<hr>
<h2 id="8-总结-3"><a href="#8-总结-3" class="headerlink" title="8. 总结"></a><strong>8. 总结</strong></h2><table>
<thead>
<tr>
<th><strong>负载均衡算法</strong></th>
<th><strong>特点</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>优缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>轮询（Round Robin）</strong></td>
<td>请求轮流分配</td>
<td>负载均衡要求较低、服务器负载均衡的场景</td>
<td>✅ 简单高效 ❌ 无法动态调整</td>
</tr>
<tr>
<td><strong>最小连接数（Least Connections）</strong></td>
<td>基于最小连接数的服务器优先分配</td>
<td>长连接、高并发应用</td>
<td>✅ 适应性较好 ❌ 不能动态适应负载变化</td>
</tr>
<tr>
<td><strong>负载感知（Adaptive Load Balancing）</strong></td>
<td>动态调整负载、实时评估服务器状态</td>
<td>高负载波动、大规模系统</td>
<td>✅ 灵活、动态调整 ❌ 配置复杂</td>
</tr>
<tr>
<td><strong>动态反馈算法（DFA）</strong></td>
<td>实时收集反馈并动态调整流量分配</td>
<td>高负载波动、大规模系统、高并发场景</td>
<td>✅ 实时反馈、动态调整 ❌ 计算和实现复杂</td>
</tr>
</tbody></table>
<h3 id="选择建议-7"><a href="#选择建议-7" class="headerlink" title="选择建议"></a><strong>选择建议</strong></h3><ul>
<li><strong>对负载变化高度敏感的应用</strong>：✅ <strong>动态反馈算法（DFA）</strong></li>
<li><strong>高负载波动和突发流量的应用</strong>：✅ <strong>负载感知（Adaptive Load Balancing）</strong></li>
<li><strong>简单实现、负载均衡要求较低的场景</strong>：✅ <strong>轮询（Round Robin）</strong></li>
</ul>

      </section>

      
      
        <nav class="article-nav">
          
            <div class="article-nav-item layout-padding">
  <article class="card-container article-nav-card content-padding--primary soft-size--large soft-style--box">
    
      <div class="card-cover" background-image-lazy data-img="/1730167239445173016723980.jpg"></div>
    
    <div class="card-text">
      
        <a href="/2024/04/06/%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B0%E7%AE%97%E6%B3%95/" itemprop="url">
          <h2 class="card-text--title text-ellipsis">流量削峰算法</h2>
        </a>
      
      <div class="card-text--row">Newer</div>
    </div>
  </article>
</div>
          
          
            <div class="article-nav-item layout-padding">
  <article class="card-container article-nav-card content-padding--primary soft-size--large soft-style--box">
    
      <div class="card-cover" background-image-lazy data-img="/1704215542946170421554257.jpg"></div>
    
    <div class="card-text">
      
        <a href="/2024/04/06/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/" itemprop="url">
          <h2 class="card-text--title text-ellipsis">雪花算法</h2>
        </a>
      
      <div class="card-text--row">Older</div>
    </div>
  </article>
</div>
          
        </nav>
      

      <section class="page-message-container layout-padding">
        


  
  

  
  


      </section>
    </div>
    <div class="widget-info">
      <section class="widget-author widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-body">
    
      <img src="/avatar.jpg" class="soft-size--round soft-style--box" alt="长情">
    
    
      <h2>长情</h2>
    
    
      <p>让物联网再次伟大</p>
    

    <div class="count-box">
      <div class="count-box--item">
        <svg class="icon icon-article" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M240.51564747 647.74217627h196.07203239c16.59071043 0 30.16492806-13.57421762 30.16492805-30.16492806V165.10332731c0-33.18142087-30.16492806-60.32985613-60.32985612-60.32985611H245.04038668C225.43318342 104.7734712 210.35071939 119.85593522 210.35071939 139.46313845V617.57724821c0 16.59071043 13.57421762 30.16492806 30.16492808 30.16492806z m663.62841731-452.47392089v482.63884894c0 33.18142087-27.14843525 60.32985613-60.32985612 60.32985613H180.18579134c-33.18142087 0-60.32985613-27.14843525-60.32985612-60.32985613V195.26825538c-49.77213131 0-90.49478418 40.72265287-90.49478417 90.49478417v452.4739209c0 49.77213131 40.72265287 90.49478418 90.49478417 90.49478417h286.56681657c16.59071043 0 30.16492806 13.57421762 30.16492807 30.16492807s13.57421762 30.16492806 30.16492805 30.16492806h90.49478418c16.59071043 0 30.16492806-13.57421762 30.16492805-30.16492806s13.57421762-30.16492806 30.16492807-30.16492807h286.56681657c49.77213131 0 90.49478418-40.72265287 90.49478417-90.49478417V285.76303955c0-49.77213131-40.72265287-90.49478418-90.49478417-90.49478417zM587.41232014 647.74217627h191.54729318c19.60720323 0 34.68966726-15.08246403 34.68966729-34.68966727V134.93839925c0-16.59071043-13.57421762-30.16492806-30.16492808-30.16492805H617.57724821c-30.16492806 0-60.32985613 27.14843525-60.32985612 60.32985611v452.4739209c0 16.59071043 13.57421762 30.16492806 30.16492805 30.16492806z" fill="currentColor"></path>
</svg>
        <span>10</span>
      </div>
      <div class="count-box--item">
        <svg class="icon icon-categories" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M900.3614811 257.09082106h-339.81629553l-67.96326003-101.9448889c-19.41807444-29.12711113-48.54518557-43.69066667-82.52681443-43.69066667H123.6385189c-53.39970333 0-97.09036999 43.69066667-97.09037113 97.09036999v582.54222222c0 53.39970333 43.69066667 97.09036999 97.09037113 97.09037002h776.7229622c53.39970333 0 97.09036999-43.69066667 97.09037113-97.09037002V354.18119104c0-53.39970333-43.69066667-97.09036999-97.09037113-97.09036998z m-97.09036999 242.72592554H220.72888889c-24.27259221 0-48.54518557-24.27259221-48.54518556-48.54518556s24.27259221-48.54518557 48.54518556-48.54518444h582.54222222c24.27259221 0 48.54518557 24.27259221 48.54518556 48.54518444s-24.27259221 48.54518557-48.54518556 48.54518556z" fill="currentColor"></path>
</svg>
        0
      </div>
      <div class="count-box--item">
        <svg class="icon icon-tags" viewBox="0 0 1098 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M283.42180005 272q0-28.38857157-20.09142843-48.48000001t-48.47999998-20.09142842-48.48000002 20.09142842-20.09142846 48.48000001 20.09142846 48.48 48.48000002 20.09142843 48.47999998-20.09142843 20.09142843-48.48zM855.0332285 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.03999997 263.58857157q-20.9142853 19.81714313-48.75428534 19.81714312-28.38857157 0-48.20571468-19.81714312l-383.04-383.58857157q-20.36571468-19.81714313-34.55999999-54.10285688t-14.19428534-62.6742853l0-222.85714313q0-27.84000002 20.36571469-48.20571469t48.2057147-20.36571466l222.85714313 0q28.38857157 0 62.6742853 14.19428529t54.65142842 34.55999999l383.04000001 382.49142843q19.81714313 20.9142853 19.81714314 48.75428532zM1060.74751475 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.04 263.58857157q-20.9142853 19.81714313-48.75428531 19.81714312-19.26857155 0-31.61142843-7.47428531t-28.38857159-24.13714314l251.79428534-251.7942853q19.81714313-19.81714313 19.81714308-48.20571469 0-27.84000002-19.81714308-48.75428531l-383.04000001-382.49142845q-20.36571468-20.36571468-54.65142842-34.55999999t-62.67428532-14.19428534l120 0q28.38857157 0 62.67428532 14.19428534t54.65142842 34.55999999l383.03999998 382.49142845q19.81714313 20.9142853 19.81714314 48.75428531z" fill="currentColor"></path>
</svg>
        1
      </div>
    </div>
  </div>
</section>

      

      
<section class="widet-notice widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-notice" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M512 945.02305225v28.15620663a24.27259221 24.27259221 0 0 1-24.27259221 24.27259335H394.0352a48.54518557 48.54518557 0 0 1-41.74885888-23.78714112l-110.68302222-184.47170332a132.04290333 132.04290333 0 0 1-17.47626667-48.54518557h118.4502511a200.97706667 200.97706667 0 0 1 76.21594113 14.56355556l20.38897777 133.49925888a48.54518557 48.54518557 0 0 0 36.40888888 27.67075555l16.01991111 2.91271112a24.27259221 24.27259221 0 0 1 20.38897778 25.72894889zM997.45185223 463.45481443a194.18074112 194.18074112 0 0 1-38.8361489 116.50844445 24.75804445 24.75804445 0 0 1-36.4088889 0l-34.95253333-34.95253333a24.27259221 24.27259221 0 0 1-2.91271111-30.58346667 97.09036999 97.09036999 0 0 0 0-106.79940665 24.27259221 24.27259221 0 0 1 2.91271111-30.58346666l34.95253333-34.95253334a24.75804445 24.75804445 0 0 1 18.93262223-7.28177777 26.2144 26.2144 0 0 1 17.47626667 9.70903665A194.18074112 194.18074112 0 0 1 997.45185223 463.45481443z m-194.18074112-388.36148111v776.72296335a48.54518557 48.54518557 0 0 1-48.54518556 48.54518443h-28.64165888a48.54518557 48.54518557 0 0 1-33.98163001-14.07810332l-145.63555556-143.20829668A291.27111111 291.27111111 0 0 0 342.57730333 657.63555556H172.18370333a145.63555556 145.63555556 0 0 1-145.63555556-145.63555556v-97.09036999a145.63555556 145.63555556 0 0 1 145.63555556-145.63555556h170.3936a291.27111111 291.27111111 0 0 0 206.31703779-85.43952668l145.63555555-143.20829554a48.54518557 48.54518557 0 0 1 33.98162888-14.07810446H754.72592555a48.54518557 48.54518557 0 0 1 48.54518556 48.54518555z" fill="currentColor"></path>
</svg>
    <span>NOTICE</span>
  </div>
  <div class="widget-body">
    <p>高举中国特色社会主义的伟大旗帜</p>
  </div>
</section>


      <section class="widget-categories widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-categories" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M900.3614811 257.09082106h-339.81629553l-67.96326003-101.9448889c-19.41807444-29.12711113-48.54518557-43.69066667-82.52681443-43.69066667H123.6385189c-53.39970333 0-97.09036999 43.69066667-97.09037113 97.09036999v582.54222222c0 53.39970333 43.69066667 97.09036999 97.09037113 97.09037002h776.7229622c53.39970333 0 97.09036999-43.69066667 97.09037113-97.09037002V354.18119104c0-53.39970333-43.69066667-97.09036999-97.09037113-97.09036998z m-97.09036999 242.72592554H220.72888889c-24.27259221 0-48.54518557-24.27259221-48.54518556-48.54518556s24.27259221-48.54518557 48.54518556-48.54518444h582.54222222c24.27259221 0 48.54518557 24.27259221 48.54518556 48.54518444s-24.27259221 48.54518557-48.54518556 48.54518556z" fill="currentColor"></path>
</svg>
      <span>CATEGORIES</span>
  </div>
  <div class="widget-body">
    <ul class="categories-list">
      
    </ul>
  </div>
</section>

      <section class="widget-tags widget-item  layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-tags" viewBox="0 0 1098 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M283.42180005 272q0-28.38857157-20.09142843-48.48000001t-48.47999998-20.09142842-48.48000002 20.09142842-20.09142846 48.48000001 20.09142846 48.48 48.48000002 20.09142843 48.47999998-20.09142843 20.09142843-48.48zM855.0332285 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.03999997 263.58857157q-20.9142853 19.81714313-48.75428534 19.81714312-28.38857157 0-48.20571468-19.81714312l-383.04-383.58857157q-20.36571468-19.81714313-34.55999999-54.10285688t-14.19428534-62.6742853l0-222.85714313q0-27.84000002 20.36571469-48.20571469t48.2057147-20.36571466l222.85714313 0q28.38857157 0 62.6742853 14.19428529t54.65142842 34.55999999l383.04000001 382.49142843q19.81714313 20.9142853 19.81714314 48.75428532zM1060.74751475 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.04 263.58857157q-20.9142853 19.81714313-48.75428531 19.81714312-19.26857155 0-31.61142843-7.47428531t-28.38857159-24.13714314l251.79428534-251.7942853q19.81714313-19.81714313 19.81714308-48.20571469 0-27.84000002-19.81714308-48.75428531l-383.04000001-382.49142845q-20.36571468-20.36571468-54.65142842-34.55999999t-62.67428532-14.19428534l120 0q28.38857157 0 62.67428532 14.19428534t54.65142842 34.55999999l383.03999998 382.49142845q19.81714313 20.9142853 19.81714314 48.75428531z" fill="currentColor"></path>
</svg>
    <span>TAGS</span>
  </div>
  <div class="widget-body">
    <div class="tags-cloud">
      <a href="/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/" style="font-size: 10px;" class="tags-cloud-0">服务端常用算法</a>
    </div>
  </div>
</section>
    </div>
  </article>
</div>

    <!-- footer container -->
<footer id="footer" class="footer">
  <div class="footer-container">
    
    <div class="social-icons">
      
        
      
        
      
        
      
        
          <a href="https://github.com/XiaoMingCloud" class="soft-size--primary soft-style--box" target="_blank" rel="noopener noreferrer">
            <svg class="icon icon-github" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M64.6 512c0 195.6 125.4 361.9 300.1 422.9 23.5 5.9 19.9-10.8 19.9-22.2v-77.6c-135.8 15.9-141.3-74-150.5-89-18.5-31.5-61.9-39.5-49-54.5 31-15.9 62.5 4 98.9 58 26.4 39.1 77.9 32.5 104.1 26 5.7-23.5 17.9-44.5 34.7-60.9-140.7-25.2-199.4-111.1-199.4-213.3 0-49.5 16.4-95.1 48.4-131.8-20.4-60.6 1.9-112.4 4.9-120.1 58.2-5.2 118.5 41.6 123.3 45.3 33.1-8.9 70.8-13.7 112.9-13.7 42.4 0 80.3 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.4-43.9 2.9 7.7 24.7 58.3 5.5 118.1 32.5 36.8 49 82.8 49 132.4 0 102.3-59 188.3-200.2 213.2 23.5 23.3 38.1 55.5 38.1 91.1v112.7c0.8 9 0 17.9 15.1 17.9C832.7 877 960.4 709.4 960.4 512.1c0-247.5-200.6-447.9-447.9-447.9C265 64.1 64.6 264.5 64.6 512z"></path>
</svg>
          </a>
        
      
        
      
    </div>
     
    <p>&copy; 2025 <a href="/" target="_blank">长情</a></p>

    


  


    <p>
      <a href="javascript:;" id="theme-light">🌞 浅色</a>
      <a href="javascript:;" id="theme-dark">🌛 深色</a>
      <a href="javascript:;" id="theme-auto">🤖️ 自动</a>
    </p>

    <p>
      <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
      <script>
      var now = new Date(); 
      function createtime() { 
          var grt= new Date("06/24/2022 20:26:16");//在此处修改你的建站时间，格式：月/日/年 时:分:秒
          now.setTime(now.getTime()+250); 
          days = (now - grt ) / 1000 / 60 / 60 / 24; 
          dnum = Math.floor(days); 
          hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); 
          hnum = Math.floor(hours); 
          if(String(hnum).length ==1 ){hnum = "0" + hnum;}
              minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
          mnum = Math.floor(minutes); 
          if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
          seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
          snum = Math.round(seconds); 
          if(String(snum).length ==1 ){snum = "0" + snum;} 
          document.getElementById("timeDate").innerHTML = "本站已运行 "+dnum+" 天 "; 
          document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
      } 
      setInterval("createtime()",250);
      </script>
  </p>
  
  </div>
</footer>
  </div>

  <div class="back-to-top-fixed soft-size--round soft-style--box">
    <svg class="icon icon-back-to-top" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
      <path d="M725.333333 426.666667c-12.8 0-21.333333-4.266667-29.866667-12.8l-213.333333-213.333333c-17.066667-17.066667-17.066667-42.666667 0-59.733333s42.666667-17.066667 59.733333 0l213.333333 213.333333c17.066667 17.066667 17.066667 42.666667 0 59.733333C746.666667 422.4 738.133333 426.666667 725.333333 426.666667z"></path>
      <path d="M298.666667 426.666667c-12.8 0-21.333333-4.266667-29.866667-12.8-17.066667-17.066667-17.066667-42.666667 0-59.733333l213.333333-213.333333c17.066667-17.066667 42.666667-17.066667 59.733333 0s17.066667 42.666667 0 59.733333l-213.333333 213.333333C320 422.4 311.466667 426.666667 298.666667 426.666667z"></path>
      <path d="M512 896c-25.6 0-42.666667-17.066667-42.666667-42.666667L469.333333 170.666667c0-25.6 17.066667-42.666667 42.666667-42.666667s42.666667 17.066667 42.666667 42.666667l0 682.666667C554.666667 878.933333 537.6 896 512 896z"></path>
    </svg>
  </div>

  
  






<!-- copy button  -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script>

<!-- https://clipboardjs.com/ -->










  


  


  




<script src="/js/script.js"></script>


  
  <!-- 尾部用户自定义相关内容 -->
</body>
</html>
